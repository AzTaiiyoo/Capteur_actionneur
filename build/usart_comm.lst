ARM GAS  /tmp/cctjDkMZ.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"usart_comm.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "Src/module/usart_comm.c"
  20              		.section	.rodata.sendMessage.str1.4,"aMS",%progbits,1
  21              		.align	2
  22              	.LC0:
  23 0000 4572726F 		.ascii	"Error: Message too long\000"
  23      723A204D 
  23      65737361 
  23      67652074 
  23      6F6F206C 
  24              		.section	.text.sendMessage,"ax",%progbits
  25              		.align	1
  26              		.global	sendMessage
  27              		.syntax unified
  28              		.thumb
  29              		.thumb_func
  31              	sendMessage:
  32              	.LVL0:
  33              	.LFB134:
   1:Src/module/usart_comm.c **** 
   2:Src/module/usart_comm.c **** /**
   3:Src/module/usart_comm.c ****  * @file usart_comm.c
   4:Src/module/usart_comm.c ****  * @brief Implémentation des fonctions de communication USART
   5:Src/module/usart_comm.c ****  */
   6:Src/module/usart_comm.c **** 
   7:Src/module/usart_comm.c **** /* INCLUDES */
   8:Src/module/usart_comm.c **** /* -------- */
   9:Src/module/usart_comm.c **** #include "stm32f4xx_hal.h"
  10:Src/module/usart_comm.c **** #include <stdlib.h>
  11:Src/module/usart_comm.c **** #include <string.h>
  12:Src/module/usart_comm.c **** #include "usart.h"
  13:Src/module/usart_comm.c **** #include <stdbool.h>
  14:Src/module/usart_comm.c **** #include "usart_comm.h"
  15:Src/module/usart_comm.c **** 
  16:Src/module/usart_comm.c **** /* MACROS */
  17:Src/module/usart_comm.c **** /* ------ */
  18:Src/module/usart_comm.c **** /**
  19:Src/module/usart_comm.c ****  * @def USART_TIMEOUT
  20:Src/module/usart_comm.c ****  * @brief Timeout pour la communication USART en millisecondes
  21:Src/module/usart_comm.c ****  */
ARM GAS  /tmp/cctjDkMZ.s 			page 2


  22:Src/module/usart_comm.c **** #define USART_TIMEOUT 1000 // Timeout for USART communication in milliseconds
  23:Src/module/usart_comm.c **** 
  24:Src/module/usart_comm.c **** /**
  25:Src/module/usart_comm.c ****  * @def USART_BUFFER_SIZE
  26:Src/module/usart_comm.c ****  * @brief Taille des buffers pour la communication USART
  27:Src/module/usart_comm.c ****  */
  28:Src/module/usart_comm.c **** #define USART_BUFFER_SIZE 256 // Buffer size for USART communication
  29:Src/module/usart_comm.c **** 
  30:Src/module/usart_comm.c **** /* VARIABLES*/
  31:Src/module/usart_comm.c **** /* --------- */
  32:Src/module/usart_comm.c **** /** @brief Handle UART pour USART2 (généré par CubeMX) */
  33:Src/module/usart_comm.c **** extern UART_HandleTypeDef huart2;
  34:Src/module/usart_comm.c **** 
  35:Src/module/usart_comm.c **** /** @brief Buffer pour la réception de données */
  36:Src/module/usart_comm.c **** uint8_t rxBuffer[USART_BUFFER_SIZE];
  37:Src/module/usart_comm.c **** 
  38:Src/module/usart_comm.c **** /** @brief Buffer pour l'envoi de données */
  39:Src/module/usart_comm.c **** uint8_t txBuffer[USART_BUFFER_SIZE];
  40:Src/module/usart_comm.c **** 
  41:Src/module/usart_comm.c **** /* FUNCTION DEFINITIONS */
  42:Src/module/usart_comm.c **** /* -------------------- */
  43:Src/module/usart_comm.c **** 
  44:Src/module/usart_comm.c **** /**
  45:Src/module/usart_comm.c ****  * @brief Envoie un message formaté via USART
  46:Src/module/usart_comm.c ****  * @param message Pointeur vers la chaîne de caractères à envoyer
  47:Src/module/usart_comm.c ****  * @details Le message est encapsulé entre les caractères '<' et '>'
  48:Src/module/usart_comm.c ****  */
  49:Src/module/usart_comm.c **** void sendMessage(char* message) {
  34              		.loc 1 49 33 view -0
  35              		.cfi_startproc
  36              		@ args = 0, pretend = 0, frame = 0
  37              		@ frame_needed = 0, uses_anonymous_args = 0
  38              		.loc 1 49 33 is_stmt 0 view .LVU1
  39 0000 70B5     		push	{r4, r5, r6, lr}
  40              	.LCFI0:
  41              		.cfi_def_cfa_offset 16
  42              		.cfi_offset 4, -16
  43              		.cfi_offset 5, -12
  44              		.cfi_offset 6, -8
  45              		.cfi_offset 14, -4
  46 0002 0546     		mov	r5, r0
  50:Src/module/usart_comm.c ****     size_t messageLen = strlen(message);
  47              		.loc 1 50 5 is_stmt 1 view .LVU2
  48              		.loc 1 50 25 is_stmt 0 view .LVU3
  49 0004 FFF7FEFF 		bl	strlen
  50              	.LVL1:
  51:Src/module/usart_comm.c ****     
  52:Src/module/usart_comm.c ****     // Vérification que le message + délimiteurs tient dans le buffer
  53:Src/module/usart_comm.c ****     if (messageLen < USART_BUFFER_SIZE - 3) { // -3 pour '<', '>' et '\0'
  51              		.loc 1 53 5 is_stmt 1 view .LVU4
  52              		.loc 1 53 8 is_stmt 0 view .LVU5
  53 0008 FC28     		cmp	r0, #252
  54 000a 1ED8     		bhi	.L2
  55 000c 0446     		mov	r4, r0
  54:Src/module/usart_comm.c ****         // Nettoyage du buffer d'envoi
  55:Src/module/usart_comm.c ****         memset(txBuffer, 0, sizeof(txBuffer));
  56              		.loc 1 55 9 is_stmt 1 view .LVU6
ARM GAS  /tmp/cctjDkMZ.s 			page 3


  57 000e 214E     		ldr	r6, .L5
  58 0010 4FF48072 		mov	r2, #256
  59 0014 0021     		movs	r1, #0
  60 0016 3046     		mov	r0, r6
  61              	.LVL2:
  62              		.loc 1 55 9 is_stmt 0 view .LVU7
  63 0018 FFF7FEFF 		bl	memset
  64              	.LVL3:
  56:Src/module/usart_comm.c **** 
  57:Src/module/usart_comm.c ****         // Début du message
  58:Src/module/usart_comm.c ****         txBuffer[0] = 0x3C; // '<'
  65              		.loc 1 58 9 is_stmt 1 view .LVU8
  66              		.loc 1 58 21 is_stmt 0 view .LVU9
  67 001c 3046     		mov	r0, r6
  68 001e 3C23     		movs	r3, #60
  69 0020 00F8013B 		strb	r3, [r0], #1
  59:Src/module/usart_comm.c ****         
  60:Src/module/usart_comm.c ****         // Copie sécurisée du message
  61:Src/module/usart_comm.c ****         memcpy(txBuffer + 1, message, messageLen);
  70              		.loc 1 61 9 is_stmt 1 view .LVU10
  71 0024 2246     		mov	r2, r4
  72 0026 2946     		mov	r1, r5
  73 0028 FFF7FEFF 		bl	memcpy
  74              	.LVL4:
  62:Src/module/usart_comm.c ****         
  63:Src/module/usart_comm.c ****         // Fin du message
  64:Src/module/usart_comm.c ****         txBuffer[messageLen + 1] = 0x3E; // '>'
  75              		.loc 1 64 9 view .LVU11
  76              		.loc 1 64 29 is_stmt 0 view .LVU12
  77 002c 631C     		adds	r3, r4, #1
  78              		.loc 1 64 34 view .LVU13
  79 002e 3E22     		movs	r2, #62
  80 0030 F254     		strb	r2, [r6, r3]
  65:Src/module/usart_comm.c ****         txBuffer[messageLen + 2] = '\0'; // Terminaison de la chaîne
  81              		.loc 1 65 9 is_stmt 1 view .LVU14
  82              		.loc 1 65 29 is_stmt 0 view .LVU15
  83 0032 A31C     		adds	r3, r4, #2
  84              		.loc 1 65 34 view .LVU16
  85 0034 0022     		movs	r2, #0
  86 0036 F254     		strb	r2, [r6, r3]
  66:Src/module/usart_comm.c ****         
  67:Src/module/usart_comm.c ****         // Envoi du message (sans le '\0' final)
  68:Src/module/usart_comm.c ****         HAL_UART_Transmit(&huart2, txBuffer, messageLen + 2, USART_TIMEOUT);
  87              		.loc 1 68 9 is_stmt 1 view .LVU17
  88 0038 1A46     		mov	r2, r3
  89 003a 4FF47A73 		mov	r3, #1000
  90 003e 92B2     		uxth	r2, r2
  91 0040 3146     		mov	r1, r6
  92 0042 1548     		ldr	r0, .L5+4
  93 0044 FFF7FEFF 		bl	HAL_UART_Transmit
  94              	.LVL5:
  95              	.L1:
  69:Src/module/usart_comm.c ****     }
  70:Src/module/usart_comm.c ****     else {
  71:Src/module/usart_comm.c ****         // Message d'erreur
  72:Src/module/usart_comm.c ****         const char* errorMsg = "Error: Message too long";
  73:Src/module/usart_comm.c ****         size_t errorLen = strlen(errorMsg);
ARM GAS  /tmp/cctjDkMZ.s 			page 4


  74:Src/module/usart_comm.c ****         
  75:Src/module/usart_comm.c ****         txBuffer[0] = 0x3C; // '<'
  76:Src/module/usart_comm.c ****         memcpy(txBuffer + 1, errorMsg, errorLen);
  77:Src/module/usart_comm.c ****         txBuffer[errorLen + 1] = 0x3E; // '>'
  78:Src/module/usart_comm.c ****         txBuffer[errorLen + 2] = '\0'; // Terminaison
  79:Src/module/usart_comm.c ****         
  80:Src/module/usart_comm.c ****         HAL_UART_Transmit(&huart2, txBuffer, errorLen + 2, USART_TIMEOUT);
  81:Src/module/usart_comm.c ****     }
  82:Src/module/usart_comm.c **** }
  96              		.loc 1 82 1 is_stmt 0 view .LVU18
  97 0048 70BD     		pop	{r4, r5, r6, pc}
  98              	.LVL6:
  99              	.L2:
 100              	.LBB2:
  72:Src/module/usart_comm.c ****         size_t errorLen = strlen(errorMsg);
 101              		.loc 1 72 9 is_stmt 1 view .LVU19
  73:Src/module/usart_comm.c ****         
 102              		.loc 1 73 9 view .LVU20
  75:Src/module/usart_comm.c ****         memcpy(txBuffer + 1, errorMsg, errorLen);
 103              		.loc 1 75 9 view .LVU21
  75:Src/module/usart_comm.c ****         memcpy(txBuffer + 1, errorMsg, errorLen);
 104              		.loc 1 75 21 is_stmt 0 view .LVU22
 105 004a 124D     		ldr	r5, .L5
 106              	.LVL7:
  75:Src/module/usart_comm.c ****         memcpy(txBuffer + 1, errorMsg, errorLen);
 107              		.loc 1 75 21 view .LVU23
 108 004c AC46     		mov	ip, r5
 109 004e 3C23     		movs	r3, #60
 110 0050 0CF8013B 		strb	r3, [ip], #1
  76:Src/module/usart_comm.c ****         txBuffer[errorLen + 1] = 0x3E; // '>'
 111              		.loc 1 76 9 is_stmt 1 view .LVU24
 112 0054 114C     		ldr	r4, .L5+8
 113 0056 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 114              	.LVL8:
  76:Src/module/usart_comm.c ****         txBuffer[errorLen + 1] = 0x3E; // '>'
 115              		.loc 1 76 9 is_stmt 0 view .LVU25
 116 0058 C5F80100 		str	r0, [r5, #1]	@ unaligned
 117 005c CCF80410 		str	r1, [ip, #4]	@ unaligned
 118 0060 CCF80820 		str	r2, [ip, #8]	@ unaligned
 119 0064 CCF80C30 		str	r3, [ip, #12]	@ unaligned
 120 0068 2068     		ldr	r0, [r4]
 121 006a CCF81000 		str	r0, [ip, #16]	@ unaligned
 122 006e A288     		ldrh	r2, [r4, #4]	@ unaligned
 123 0070 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 124 0072 ACF81420 		strh	r2, [ip, #20]	@ unaligned
 125 0076 8CF81630 		strb	r3, [ip, #22]
  77:Src/module/usart_comm.c ****         txBuffer[errorLen + 2] = '\0'; // Terminaison
 126              		.loc 1 77 9 is_stmt 1 view .LVU26
  77:Src/module/usart_comm.c ****         txBuffer[errorLen + 2] = '\0'; // Terminaison
 127              		.loc 1 77 32 is_stmt 0 view .LVU27
 128 007a 3E23     		movs	r3, #62
 129 007c 2B76     		strb	r3, [r5, #24]
  78:Src/module/usart_comm.c ****         
 130              		.loc 1 78 9 is_stmt 1 view .LVU28
  78:Src/module/usart_comm.c ****         
 131              		.loc 1 78 32 is_stmt 0 view .LVU29
 132 007e 0023     		movs	r3, #0
ARM GAS  /tmp/cctjDkMZ.s 			page 5


 133 0080 6B76     		strb	r3, [r5, #25]
  80:Src/module/usart_comm.c ****     }
 134              		.loc 1 80 9 is_stmt 1 view .LVU30
 135 0082 4FF47A73 		mov	r3, #1000
 136 0086 1922     		movs	r2, #25
 137 0088 2946     		mov	r1, r5
 138 008a 0348     		ldr	r0, .L5+4
 139 008c FFF7FEFF 		bl	HAL_UART_Transmit
 140              	.LVL9:
 141              	.LBE2:
 142              		.loc 1 82 1 is_stmt 0 view .LVU31
 143 0090 DAE7     		b	.L1
 144              	.L6:
 145 0092 00BF     		.align	2
 146              	.L5:
 147 0094 00000000 		.word	txBuffer
 148 0098 00000000 		.word	huart2
 149 009c 00000000 		.word	.LC0
 150              		.cfi_endproc
 151              	.LFE134:
 153              		.section	.rodata.receiveMessage.str1.4,"aMS",%progbits,1
 154              		.align	2
 155              	.LC1:
 156 0000 0D0A00   		.ascii	"\015\012\000"
 157 0003 00       		.align	2
 158              	.LC2:
 159 0004 0D0A4275 		.ascii	"\015\012Buffer overflow\015\012\000"
 159      66666572 
 159      206F7665 
 159      72666C6F 
 159      770D0A00 
 160              		.section	.text.receiveMessage,"ax",%progbits
 161              		.align	1
 162              		.global	receiveMessage
 163              		.syntax unified
 164              		.thumb
 165              		.thumb_func
 167              	receiveMessage:
 168              	.LVL10:
 169              	.LFB135:
  83:Src/module/usart_comm.c **** 
  84:Src/module/usart_comm.c **** /**
  85:Src/module/usart_comm.c ****  * @brief Reçoit un message formaté via USART de manière non-bloquante
  86:Src/module/usart_comm.c ****  * @param buffer Pointeur vers le buffer où stocker le message reçu
  87:Src/module/usart_comm.c ****  * @param maxSize Taille maximale du buffer
  88:Src/module/usart_comm.c ****  * @return Nombre de caractères reçus, ou -1 si aucun message complet n'a été reçu
  89:Src/module/usart_comm.c ****  * @details Cette fonction est non-bloquante. Elle retourne -1 si aucun message
  90:Src/module/usart_comm.c ****  * complet (délimité par '<' et '>') n'a été reçu. Les caractères reçus sont
  91:Src/module/usart_comm.c ****  * également envoyés en écho sur le terminal.
  92:Src/module/usart_comm.c ****  */
  93:Src/module/usart_comm.c **** int receiveMessage(char* buffer, size_t maxSize) {
 170              		.loc 1 93 50 is_stmt 1 view -0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 8
 173              		@ frame_needed = 0, uses_anonymous_args = 0
 174              		.loc 1 93 50 is_stmt 0 view .LVU33
 175 0000 F0B5     		push	{r4, r5, r6, r7, lr}
ARM GAS  /tmp/cctjDkMZ.s 			page 6


 176              	.LCFI1:
 177              		.cfi_def_cfa_offset 20
 178              		.cfi_offset 4, -20
 179              		.cfi_offset 5, -16
 180              		.cfi_offset 6, -12
 181              		.cfi_offset 7, -8
 182              		.cfi_offset 14, -4
 183 0002 83B0     		sub	sp, sp, #12
 184              	.LCFI2:
 185              		.cfi_def_cfa_offset 32
 186 0004 0546     		mov	r5, r0
 187 0006 0C46     		mov	r4, r1
  94:Src/module/usart_comm.c ****     static uint8_t receiveBuf[32];  // Buffer statique pour conserver l'état entre les appels
 188              		.loc 1 94 5 is_stmt 1 view .LVU34
  95:Src/module/usart_comm.c ****     static int index = 0;           // Index courant dans le buffer
 189              		.loc 1 95 5 view .LVU35
  96:Src/module/usart_comm.c ****     static bool startReceived = false; // Indique si on a reçu le caractère de début
 190              		.loc 1 96 5 view .LVU36
  97:Src/module/usart_comm.c ****     
  98:Src/module/usart_comm.c ****     uint8_t c;
 191              		.loc 1 98 5 view .LVU37
  99:Src/module/usart_comm.c ****     
 100:Src/module/usart_comm.c ****     // Vérifier si des données sont disponibles (non-bloquant)
 101:Src/module/usart_comm.c ****     if (HAL_UART_Receive(&huart2, &c, 1, 0) == HAL_OK) {
 192              		.loc 1 101 5 view .LVU38
 193              		.loc 1 101 9 is_stmt 0 view .LVU39
 194 0008 0023     		movs	r3, #0
 195 000a 0122     		movs	r2, #1
 196 000c 0DF10701 		add	r1, sp, #7
 197              	.LVL11:
 198              		.loc 1 101 9 view .LVU40
 199 0010 3048     		ldr	r0, .L19
 200              	.LVL12:
 201              		.loc 1 101 9 view .LVU41
 202 0012 FFF7FEFF 		bl	HAL_UART_Receive
 203              	.LVL13:
 204              		.loc 1 101 8 discriminator 1 view .LVU42
 205 0016 0028     		cmp	r0, #0
 206 0018 59D1     		bne	.L14
 207              	.LBB3:
 102:Src/module/usart_comm.c ****         // Un caractère a été reçu
 103:Src/module/usart_comm.c ****         char echoChar[2] = {c, 0};
 208              		.loc 1 103 9 is_stmt 1 view .LVU43
 209              		.loc 1 103 14 is_stmt 0 view .LVU44
 210 001a 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 211 001e 8DF80430 		strb	r3, [sp, #4]
 212 0022 0023     		movs	r3, #0
 213 0024 8DF80530 		strb	r3, [sp, #5]
 104:Src/module/usart_comm.c ****         HAL_UART_Transmit(&huart2, (uint8_t*)echoChar, 1, 10);
 214              		.loc 1 104 9 is_stmt 1 view .LVU45
 215 0028 0A23     		movs	r3, #10
 216 002a 0122     		movs	r2, #1
 217 002c 01A9     		add	r1, sp, #4
 218 002e 2948     		ldr	r0, .L19
 219 0030 FFF7FEFF 		bl	HAL_UART_Transmit
 220              	.LVL14:
 105:Src/module/usart_comm.c ****         
ARM GAS  /tmp/cctjDkMZ.s 			page 7


 106:Src/module/usart_comm.c ****         // Vérifier si c'est le caractère de début
 107:Src/module/usart_comm.c ****         if (c == '<' && !startReceived) {
 221              		.loc 1 107 9 view .LVU46
 222              		.loc 1 107 15 is_stmt 0 view .LVU47
 223 0034 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 224              		.loc 1 107 12 view .LVU48
 225 0038 3C2B     		cmp	r3, #60
 226 003a 19D0     		beq	.L16
 227              	.L9:
 108:Src/module/usart_comm.c ****             startReceived = true;
 109:Src/module/usart_comm.c ****             index = 0;
 110:Src/module/usart_comm.c ****             return -1;  // Pas encore de commande complète
 111:Src/module/usart_comm.c ****         }
 112:Src/module/usart_comm.c ****         
 113:Src/module/usart_comm.c ****         // Vérifier si c'est le caractère de fin
 114:Src/module/usart_comm.c ****         if (c == '>' && startReceived) {
 228              		.loc 1 114 9 is_stmt 1 view .LVU49
 229              		.loc 1 114 12 is_stmt 0 view .LVU50
 230 003c 3E2B     		cmp	r3, #62
 231 003e 24D0     		beq	.L17
 232              	.L11:
 115:Src/module/usart_comm.c ****             receiveBuf[index] = '\0';  // Terminer la chaîne
 116:Src/module/usart_comm.c ****             strncpy(buffer, (char*)receiveBuf, maxSize);
 117:Src/module/usart_comm.c ****             HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n", 2, 10);
 118:Src/module/usart_comm.c ****             
 119:Src/module/usart_comm.c ****             // Réinitialiser l'état
 120:Src/module/usart_comm.c ****             startReceived = false;
 121:Src/module/usart_comm.c ****             index = 0;
 122:Src/module/usart_comm.c ****             
 123:Src/module/usart_comm.c ****             return strlen(buffer);  // Commande complète
 124:Src/module/usart_comm.c ****         }
 125:Src/module/usart_comm.c ****         
 126:Src/module/usart_comm.c ****         // Si on est en train de recevoir une commande, stocker le caractère
 127:Src/module/usart_comm.c ****         if (startReceived) {
 233              		.loc 1 127 9 is_stmt 1 view .LVU51
 234              		.loc 1 127 13 is_stmt 0 view .LVU52
 235 0040 254A     		ldr	r2, .L19+4
 236 0042 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 237              		.loc 1 127 12 view .LVU53
 238 0044 002A     		cmp	r2, #0
 239 0046 3FD0     		beq	.L12
 128:Src/module/usart_comm.c ****             if (index < maxSize - 1) {
 240              		.loc 1 128 13 is_stmt 1 view .LVU54
 241              		.loc 1 128 33 is_stmt 0 view .LVU55
 242 0048 611E     		subs	r1, r4, #1
 243              		.loc 1 128 23 view .LVU56
 244 004a 244A     		ldr	r2, .L19+8
 245 004c 1268     		ldr	r2, [r2]
 246              		.loc 1 128 16 view .LVU57
 247 004e 9142     		cmp	r1, r2
 248 0050 35D8     		bhi	.L18
 129:Src/module/usart_comm.c ****                 receiveBuf[index++] = c;
 130:Src/module/usart_comm.c ****             } else {
 131:Src/module/usart_comm.c ****                 // Buffer overflow
 132:Src/module/usart_comm.c ****                 HAL_UART_Transmit(&huart2, (uint8_t*)"\r\nBuffer overflow\r\n", 18, 100);
 249              		.loc 1 132 17 is_stmt 1 view .LVU58
 250 0052 6423     		movs	r3, #100
ARM GAS  /tmp/cctjDkMZ.s 			page 8


 251 0054 1222     		movs	r2, #18
 252 0056 2249     		ldr	r1, .L19+12
 253 0058 1E48     		ldr	r0, .L19
 254 005a FFF7FEFF 		bl	HAL_UART_Transmit
 255              	.LVL15:
 133:Src/module/usart_comm.c ****                 startReceived = false;
 256              		.loc 1 133 17 view .LVU59
 257              		.loc 1 133 31 is_stmt 0 view .LVU60
 258 005e 0023     		movs	r3, #0
 259 0060 1D4A     		ldr	r2, .L19+4
 260 0062 1370     		strb	r3, [r2]
 134:Src/module/usart_comm.c ****                 index = 0;
 261              		.loc 1 134 17 is_stmt 1 view .LVU61
 262              		.loc 1 134 23 is_stmt 0 view .LVU62
 263 0064 1D4A     		ldr	r2, .L19+8
 264 0066 1360     		str	r3, [r2]
 135:Src/module/usart_comm.c ****                 return -1;
 265              		.loc 1 135 17 is_stmt 1 view .LVU63
 266              		.loc 1 135 24 is_stmt 0 view .LVU64
 267 0068 4FF0FF30 		mov	r0, #-1
 268              	.L7:
 269              		.loc 1 135 24 view .LVU65
 270              	.LBE3:
 136:Src/module/usart_comm.c ****             }
 137:Src/module/usart_comm.c ****         }
 138:Src/module/usart_comm.c ****     }
 139:Src/module/usart_comm.c ****     
 140:Src/module/usart_comm.c ****     // Aucune commande complète n'a été reçue
 141:Src/module/usart_comm.c ****     return -1;
 142:Src/module/usart_comm.c **** }...
 271              		.loc 1 142 1 view .LVU66
 272 006c 03B0     		add	sp, sp, #12
 273              	.LCFI3:
 274              		.cfi_remember_state
 275              		.cfi_def_cfa_offset 20
 276              		@ sp needed
 277 006e F0BD     		pop	{r4, r5, r6, r7, pc}
 278              	.LVL16:
 279              	.L16:
 280              	.LCFI4:
 281              		.cfi_restore_state
 282              	.LBB4:
 107:Src/module/usart_comm.c ****         if (c == '<' && !startReceived) {
 283              		.loc 1 107 25 discriminator 1 view .LVU67
 284 0070 194A     		ldr	r2, .L19+4
 285 0072 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 107:Src/module/usart_comm.c ****         if (c == '<' && !startReceived) {
 286              		.loc 1 107 22 discriminator 1 view .LVU68
 287 0074 002A     		cmp	r2, #0
 288 0076 E1D1     		bne	.L9
 108:Src/module/usart_comm.c ****             startReceived = true;
 289              		.loc 1 108 13 is_stmt 1 view .LVU69
 108:Src/module/usart_comm.c ****             startReceived = true;
 290              		.loc 1 108 27 is_stmt 0 view .LVU70
 291 0078 174B     		ldr	r3, .L19+4
 292 007a 0122     		movs	r2, #1
 293 007c 1A70     		strb	r2, [r3]
ARM GAS  /tmp/cctjDkMZ.s 			page 9


 109:Src/module/usart_comm.c ****             index = 0;
 294              		.loc 1 109 13 is_stmt 1 view .LVU71
 109:Src/module/usart_comm.c ****             index = 0;
 295              		.loc 1 109 19 is_stmt 0 view .LVU72
 296 007e 174B     		ldr	r3, .L19+8
 297 0080 0022     		movs	r2, #0
 298 0082 1A60     		str	r2, [r3]
 110:Src/module/usart_comm.c ****             return -1;  // Pas encore de commande complète
 299              		.loc 1 110 13 is_stmt 1 view .LVU73
 110:Src/module/usart_comm.c ****             return -1;  // Pas encore de commande complète
 300              		.loc 1 110 20 is_stmt 0 view .LVU74
 301 0084 4FF0FF30 		mov	r0, #-1
 302 0088 F0E7     		b	.L7
 303              	.L17:
 114:Src/module/usart_comm.c ****         if (c == '>' && startReceived) {
 304              		.loc 1 114 22 discriminator 1 view .LVU75
 305 008a 134A     		ldr	r2, .L19+4
 306 008c 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 307 008e 002A     		cmp	r2, #0
 308 0090 D6D0     		beq	.L11
 115:Src/module/usart_comm.c ****             receiveBuf[index] = '\0';  // Terminer la chaîne
 309              		.loc 1 115 13 is_stmt 1 view .LVU76
 115:Src/module/usart_comm.c ****             receiveBuf[index] = '\0';  // Terminer la chaîne
 310              		.loc 1 115 23 is_stmt 0 view .LVU77
 311 0092 124F     		ldr	r7, .L19+8
 312 0094 3B68     		ldr	r3, [r7]
 115:Src/module/usart_comm.c ****             receiveBuf[index] = '\0';  // Terminer la chaîne
 313              		.loc 1 115 31 view .LVU78
 314 0096 1349     		ldr	r1, .L19+16
 315 0098 0026     		movs	r6, #0
 316 009a CE54     		strb	r6, [r1, r3]
 116:Src/module/usart_comm.c ****             strncpy(buffer, (char*)receiveBuf, maxSize);
 317              		.loc 1 116 13 is_stmt 1 view .LVU79
 318 009c 2246     		mov	r2, r4
 319 009e 2846     		mov	r0, r5
 320 00a0 FFF7FEFF 		bl	strncpy
 321              	.LVL17:
 117:Src/module/usart_comm.c ****             HAL_UART_Transmit(&huart2, (uint8_t*)"\r\n", 2, 10);
 322              		.loc 1 117 13 view .LVU80
 323 00a4 0A23     		movs	r3, #10
 324 00a6 0222     		movs	r2, #2
 325 00a8 0F49     		ldr	r1, .L19+20
 326 00aa 0A48     		ldr	r0, .L19
 327 00ac FFF7FEFF 		bl	HAL_UART_Transmit
 328              	.LVL18:
 120:Src/module/usart_comm.c ****             startReceived = false;
 329              		.loc 1 120 13 view .LVU81
 120:Src/module/usart_comm.c ****             startReceived = false;
 330              		.loc 1 120 27 is_stmt 0 view .LVU82
 331 00b0 094B     		ldr	r3, .L19+4
 332 00b2 1E70     		strb	r6, [r3]
 121:Src/module/usart_comm.c ****             index = 0;
 333              		.loc 1 121 13 is_stmt 1 view .LVU83
 121:Src/module/usart_comm.c ****             index = 0;
 334              		.loc 1 121 19 is_stmt 0 view .LVU84
 335 00b4 3E60     		str	r6, [r7]
 123:Src/module/usart_comm.c ****             return strlen(buffer);  // Commande complète
ARM GAS  /tmp/cctjDkMZ.s 			page 10


 336              		.loc 1 123 13 is_stmt 1 view .LVU85
 123:Src/module/usart_comm.c ****             return strlen(buffer);  // Commande complète
 337              		.loc 1 123 20 is_stmt 0 view .LVU86
 338 00b6 2846     		mov	r0, r5
 339 00b8 FFF7FEFF 		bl	strlen
 340              	.LVL19:
 341 00bc D6E7     		b	.L7
 342              	.L18:
 129:Src/module/usart_comm.c ****                 receiveBuf[index++] = c;
 343              		.loc 1 129 17 is_stmt 1 view .LVU87
 129:Src/module/usart_comm.c ****                 receiveBuf[index++] = c;
 344              		.loc 1 129 33 is_stmt 0 view .LVU88
 345 00be 501C     		adds	r0, r2, #1
 346 00c0 0649     		ldr	r1, .L19+8
 347 00c2 0860     		str	r0, [r1]
 129:Src/module/usart_comm.c ****                 receiveBuf[index++] = c;
 348              		.loc 1 129 37 view .LVU89
 349 00c4 0749     		ldr	r1, .L19+16
 350 00c6 8B54     		strb	r3, [r1, r2]
 351              	.L12:
 129:Src/module/usart_comm.c ****                 receiveBuf[index++] = c;
 352              		.loc 1 129 37 view .LVU90
 353              	.LBE4:
 141:Src/module/usart_comm.c ****     return -1;
 354              		.loc 1 141 12 view .LVU91
 355 00c8 4FF0FF30 		mov	r0, #-1
 356              	.LBB5:
 357 00cc CEE7     		b	.L7
 358              	.L14:
 359              	.LBE5:
 360 00ce 4FF0FF30 		mov	r0, #-1
 361 00d2 CBE7     		b	.L7
 362              	.L20:
 363              		.align	2
 364              	.L19:
 365 00d4 00000000 		.word	huart2
 366 00d8 00000000 		.word	startReceived.2
 367 00dc 00000000 		.word	index.1
 368 00e0 04000000 		.word	.LC2
 369 00e4 00000000 		.word	receiveBuf.0
 370 00e8 00000000 		.word	.LC1
 371              		.cfi_endproc
 372              	.LFE135:
 374              		.section	.bss.receiveBuf.0,"aw",%nobits
 375              		.align	2
 378              	receiveBuf.0:
 379 0000 00000000 		.space	32
 379      00000000 
 379      00000000 
 379      00000000 
 379      00000000 
 380              		.section	.bss.index.1,"aw",%nobits
 381              		.align	2
 384              	index.1:
 385 0000 00000000 		.space	4
 386              		.section	.bss.startReceived.2,"aw",%nobits
 389              	startReceived.2:
ARM GAS  /tmp/cctjDkMZ.s 			page 11


 390 0000 00       		.space	1
 391              		.global	txBuffer
 392              		.section	.bss.txBuffer,"aw",%nobits
 393              		.align	2
 396              	txBuffer:
 397 0000 00000000 		.space	256
 397      00000000 
 397      00000000 
 397      00000000 
 397      00000000 
 398              		.global	rxBuffer
 399              		.section	.bss.rxBuffer,"aw",%nobits
 400              		.align	2
 403              	rxBuffer:
 404 0000 00000000 		.space	256
 404      00000000 
 404      00000000 
 404      00000000 
 404      00000000 
 405              		.text
 406              	.Letext0:
 407              		.file 2 "/usr/lib/gcc/arm-none-eabi/13.2.1/include/stdint.h"
 408              		.file 3 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f407xx.h"
 409              		.file 4 "/usr/lib/gcc/arm-none-eabi/13.2.1/include/stddef.h"
 410              		.file 5 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 411              		.file 6 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 412              		.file 7 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 413              		.file 8 "Inc/usart.h"
 414              		.file 9 "/usr/include/newlib/string.h"
 415              		.file 10 "<built-in>"
ARM GAS  /tmp/cctjDkMZ.s 			page 12


DEFINED SYMBOLS
                            *ABS*:00000000 usart_comm.c
     /tmp/cctjDkMZ.s:21     .rodata.sendMessage.str1.4:00000000 $d
     /tmp/cctjDkMZ.s:25     .text.sendMessage:00000000 $t
     /tmp/cctjDkMZ.s:31     .text.sendMessage:00000000 sendMessage
     /tmp/cctjDkMZ.s:147    .text.sendMessage:00000094 $d
     /tmp/cctjDkMZ.s:396    .bss.txBuffer:00000000 txBuffer
     /tmp/cctjDkMZ.s:154    .rodata.receiveMessage.str1.4:00000000 $d
     /tmp/cctjDkMZ.s:161    .text.receiveMessage:00000000 $t
     /tmp/cctjDkMZ.s:167    .text.receiveMessage:00000000 receiveMessage
     /tmp/cctjDkMZ.s:365    .text.receiveMessage:000000d4 $d
     /tmp/cctjDkMZ.s:389    .bss.startReceived.2:00000000 startReceived.2
     /tmp/cctjDkMZ.s:384    .bss.index.1:00000000 index.1
     /tmp/cctjDkMZ.s:378    .bss.receiveBuf.0:00000000 receiveBuf.0
     /tmp/cctjDkMZ.s:375    .bss.receiveBuf.0:00000000 $d
     /tmp/cctjDkMZ.s:381    .bss.index.1:00000000 $d
     /tmp/cctjDkMZ.s:390    .bss.startReceived.2:00000000 $d
     /tmp/cctjDkMZ.s:393    .bss.txBuffer:00000000 $d
     /tmp/cctjDkMZ.s:403    .bss.rxBuffer:00000000 rxBuffer
     /tmp/cctjDkMZ.s:400    .bss.rxBuffer:00000000 $d

UNDEFINED SYMBOLS
strlen
memset
memcpy
HAL_UART_Transmit
huart2
HAL_UART_Receive
strncpy
